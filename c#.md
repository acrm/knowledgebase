# Hello C#!!!

## C#
С# - это мультипарадигменный соверменный объектноориентированный язык программирования, созданный Андрэсом Хейлсбергом в компании Майкрософт. Программы, написанные на языке C# обычно работают на специальной платформе .NET, которая разработана также Microsoft обладает объектно-ориентирванной структурой и включает в себя  и составных встроенных типов данных, множество классов, именуемых .NET Framework. Это среда спроектирована так, что при ее исполнении в ней выполняется особый низкоуровневый язык, который называется Intermediate Language (MSIL) и является аналогом ассемблерного языка. Программный код, написанный программистом преобразуется на этапе компиляции в этот промежуточный язык. Далее среда выполнения преобразует промежуточный язык в машинный код. Net Framework по спецификации поддерживает множество программных языков одним из которых и, наверное, основным яляется c#.  Мультипарадигменность предполагает то, что в языке используются обычно объектноориентированные конструкции, но также на ряду с ними можно писать функциональные вставки. Часть кода можно писать императивно, а часть декларативно.

В языке преимущественно все - это объект.
Объекты реализуются как экземпляры классов. Классы - это составные типы данных список которых находится в Net Framework. 

Типы данных делятся на простые и составные. Простые типы это целочисленные, с плавающей точкой, символ. Составные - то массивы, классы, строки, перечисления и структуры.

C# имеет множество современных язывоковых конструкций. 

ООП конструкции

Обобщенные типы generic.

Атрибуты

Делегаты и события.

## ООП

Чтобы создать класс нужно написать `Person john = New Person();`
Это строка означает, что создается объект john - экземпляр класса Person. New - это ключевое слово вызова конструктора. `Person()` - это метод-конструктор, который  инициализирует экземляр класса.

Метод - это процедура (sub, function), которая содержит участок кода по изменению состояния объекта. Методы определяют поведение объектов. Вызывая метод, можно изменить состояние объекта. Объет состоит из членов класса свойств и полей. Так определяется состояние объекта. к членам объекта - свойствам и методам можно обратиться в коде через точку. `john.age = 48;` - здесь изменяется свойство age (возраст) объекта john. Чтобы вызвать метод объекта john Work(), нужно написать `John.Work()`. Внутри скобок можно передавать параметры. Можно переопределять методы изменяя количество входных параметров. Есть также выходные параметры. Если метод является типа void, то он ведет себя как процедура или субрутина и не возвращает никаких значений, а если у метода есть тип (integer, `String`, object, ...), то такой метод ведет себя как функция и может возвращать значение, используя ключевое слово return и тогда имя функции является выодным параметром.

## Основные понятия ООП

Классы и объекты являются языковыми конструкциями объектно-ориентированного программирования. ООП имеет три основных принципа. Инкапсуляция, наследование и полиморфизм. 

## Инкапсуляция
Принцип который предполагает, что у всех конструкций опп (класс, метод, свойство, поле) есть модификатор доступа. Тогда  в классе может быть доступна или не доступна ивне. Другими словами можно обращаться к элементам класса извне, или нет.

Public 

private 

protected

Также инкапсуляция выражется в том, что существуют модули, пространства имен, котрые регламентируют доступ к данным программы.
## Наследование
класс может быть наследован от другого класса родителя с копированием всех элементов. Можно добавить новые.
Существуют также абстрактные классы и интерфейсы, реализация которых не задается на уровне определения класса. А задеается на уровне определения объекта. 
## Полиморфизм
Это возможность обращаться к элементам класса-потомка на уровне реализации класса-родителя.
Ярким примером является класс фигура и наследованные от нее классы квадрат, куб, ромб. На уроне фигуры имеется абстрактный метод Draw. Реализация его задается на уровне класса-потомка, тоесть при определениии классов квадрат, ромб, куб. Обращаясь к Shape.Draw() мы можем поройти по всем классам потомкам итераатором, при условии, что они упакованы в массив.


### Пример.

#### Программа
```
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading.Tasks;

namespace SerializationExample1
{
    class Program
    {
        static void Main(string[] args)
        {
            // объект для сериализации
            Person person = new Person("Tom", 29);
            Console.WriteLine("Объект создан");


            // создадим объект BinryFormatter
            BinaryFormatter formatter = new BinaryFormatter();
            // Получаем поток, куда будем записывать сериализованный поток
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                formatter.Serialize(fs, person);

                Console.WriteLine("объект сериализован");
                

            }
            using (FileStream fs = new FileStream("people.dat", FileMode.OpenOrCreate))
            {
                Person newPerson = (Person)formatter.Deserialize(fs);
                Console.WriteLine("объект десериализован");
                Console.WriteLine("Имя: {0} --- Возраст: {1}", newPerson.Name, newPerson.Age);

            }

            Console.ReadLine();

        }
    }
}
```

#### Класс Person
``` cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Threading.Tasks;

namespace SerializationExample1
{
    [Serializable]

    class Person
    {
        public string Name { get; set; }
        public int Age { get; set; }

        public Person(string name, int age)
        {
            Name = name;
            Age = age;
        }
    }


}
```
 
